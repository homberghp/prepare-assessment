#!/bin/bash

## test if given disk reports as 'SanDisk Extreme'
## @param diskBaseName like sdc
function isSanDiskUSB(){
    local diskBaseName=$1; shift
    v=$(cat /sys/block/${diskBaseName}/device/vendor); v=${v// /} # trim spaces
    m=$(cat /sys/block/${diskBaseName}/device/model); m=${m// /} # trim spaces
    vm="$v $m"
    [[ $vm =~ ^'SanDisk Extreme' ]]
}

## Return a list of device names that appear to be SanDisk Extreme devices
## 
function enumerateSticks(){
    local result=''
    for d in /sys/block/sd*; do
	diskBaseName=$(basename $d)
	if isSanDiskUSB ${diskBaseName}; then
	    result="${result} ${diskBaseName}"
	fi
    done
    echo -n ${result};
}

# ##
# ## unmount all SanDisk Extreme USB sticks
# function unMountAllUSB(){
#     for d in $(enumerateSticks); do
	
#     done

# }

# validates that the device visible as diskBaseName is indeed
# a 'SanDisk Extreme' make and model.
# @param diskBaseName like sdc
# Notice: when running this function in a shell, and the stick is not valid, it closes the shell
function validateStick(){
    local diskBaseName=$1; shift
    
    if [ ! -e /sys/block/${diskBaseName} ] ; then
	echo "${diskBaseName} is not a suitable device or not a block device at all, bye..."
	exit 1
    fi
    ## test for SanDisk Extreme
    ## read vendor and model
    if  ! isSanDiskUSB ${diskBaseName} ; then
	echo "device /dev/${diskBaseName} should be a 'SanDisk Extreme' but was a '${vm}'"
	exit 1
    fi
    #echo "found device '$vm' at /dev/${diskBaseName}"
}

function mountAllSticks(){
    local counter=0
    for baseDisk in $(enumerateSticks); do
	local locacounter=$((${counter}+1))
	local probemount=/media/${USER}/${baseDisk}3-stickmountprobe
	local part=${baseDisk}3
	mkdir -p ${probemount}
	mount --options ro /dev/${part} ${probemount}
	local labelFile=${probemount}/upper/sebi-label
	if [ -e ${labelFile} ]; then
	    label=$(cat ${probemount}/upper/sebi-label)
	else
	    label=UNKNOWN${counter}
	fi
	## create final mount point
	local finalmount=/media/usb/${label}-writable
	mkdir -p ${finalmount}
	mount --bind --options rw ${probemount} ${finalmount}
	mount --options remount,rw /dev/${part} ${finalmount}
    done
    sync
    echo 'waiting a second for mount activity to settle down'
    sleep 1 # let the machine recover
    for probemount in $(cat /proc/mounts \
		    | grep '\-stickmountprobe' \
		    | awk '{print $2}') ; do
	umount ${probemount}
	rmdir ${probemount}
    done
}


# enumerate  mounted stick partitions
# @return the space separated list of mounted partitions
function mountedPartitions(){
    local mounted=""
    for d in $(enumerateSticks); do
	for p in $(cat  /proc/mounts \
		       | awk '{print $1}'\
		       | grep -s "/dev/${d}" ) ; do
	    if [ -z "$mounted" ]; then
		mounted="$p"
	    else
		mounted="${mounted} $p"
	    fi
	done
    done
    echo "$mounted"
}


## unmount all stick partitions
function umountAllSticks(){
    for p in $(mountedPartitions) ; do
	umount $p
    done
}


##
## write an iso image to a stick
## @param image to write
## @param ... sticks to write to
function writeImage(){
    local image=$1; shift
    echo "image to write is ${image}"
    while [ $# -ge 1 ]; do
	local disk=$1; shift
	## run as detached sub process
	(
	    validateStick ${disk}
	    unmountPartitions ${disk}
	    dd if=${image} of=/dev/${disk} bs=4M conv=fsync status=progress
	) &
    done
}


##
## make partition 3 on stick
## @param stick/ disk to use
function initPartition3(){
    local disk=$1; shift
    validateStick $disk
    ## make sfdisk use defaults for start and end, a.k.a. all remaining space
    echo "," | flock /dev/${disk} sfdisk  --quiet --append /dev/${disk} -N3
    sync /dev/${disk}
    ## make a file system in the partition
    mkfs.ext2 -q -F -L writable /dev/${disk}3
}

##
## prime a partition sdX3 with label and initial hom dirs
## @param disk partition to prime
## @param label to use
## @param user  user on stick to use
## @param skel skeleton tar file to use to create home dir
function primePartition3(){
    local disk=$1; shift
    local label=$1; shift
    ## make the partition  and create file system in partition3
    initPartition3 ${disk}
    ## mount the file system
    rootmp=/media/usb/${label}-writable
    mkdir -p ${rootmp}
    mount /dev/${disk}3 ${rootmp}
    ## create a default directory structure
    mkdir -p ${rootmp}/{upper/etc,work/work}
    ## put the label file in sebi-label and hostname
    echo ${label} | tr 'A-Z' 'a-z' > ${rootmp}/upper/etc/hostname
    echo -n ${label} > ${rootmp}/upper/sebi-label
    ## expand skel for home/<user>
    if [ -e examskel.tgz ]; then
	userhome=${rootmp}/upper/home/exam
	mkdir -p ${userhome}
	tar -C ${userhome} -xf examskel.tgz
	chown -R 1001:1001 ${userhome}
	echo "created home dir for 'exam' on device ${disk}3"
    fi
    if [ -e sebiskel.tgz ]; then
	userhome=${rootmp}/upper/home/sebi
	mkdir -p ${userhome}
	tar -C ${userhome} -xf sebiskel.tgz
	chown -R 1002:1002 ${userhome}
	echo "created home dir for 'sebi' on device ${disk}3"
    fi
    sync /dev/${disk}3
    umount ${rootmp}
}

## mount the use stick as /media/usb/<label>-writable
## as in /media/usb/EXAM350-writable
## @param old mount point 
## @param label
function remount(){
    local omp=$1; shift
    local label=$1; shift
    local nmp=/media/usb/${label}-writable
    mkdir -p ${nmp}
    mount --bind ${omp} ${nmp}
    umount ${omp}
}

##
## Prepare a set of stick with stick class, image and initial label number.
## example prepareSticks EXAM image.iso 350 sdc sdd sde sdf
## @param stick_class EXAM oe SEBI
## @param image the iso file to use
## @param diskNr the initial disk number
## @param disk1 [disk2 [...]]
function prepareSticks(){
    local stick_class=$1; shift
    local image=$1; shift
    local diskNr=$1; shift
    while [ $# -ge 1 ]; do
	local disk=$1; shift
	local label=${stick_class}${diskNr}
	validateStick ${disk}
	## run as detached sub process
	(
	    unmountPartitions ${disk}
	    dd if=${image} of=/dev/${disk} bs=4M conv=fsync
	    echo "writing base iso to ${disk} completed"
	    primePartition3 ${disk} ${label}
	) &
	diskNr=$((${diskNr+1}))
    done
    echo "wait for completion"
    wait
    echo "all child processes returned"
}


