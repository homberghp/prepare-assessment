#!/bin/bash


## Set of functions to manipulate sticks for exam image preparation.
##
## @author pieter.van.den.hombergh@gmail.com


## Get device name by reading vendor and model from /sys/bloc pseudo file system.
## @param diskBaseName name of device like sdd or sde
function blockDeviceName(){
    local diskBaseName=$1; shift
    if [ -z "$diskBaseName" ]; then 
        echo "paramater not set"
        false
    fi
    v=$(cat /sys/block/${diskBaseName}/device/vendor); v=${v// /} # trim spaces
    m=$(cat /sys/block/${diskBaseName}/device/model); m=${m// /} # trim spaces
    echo "$v $m"
}

## 
## test if given disk reports as 'SanDisk Extreme'
## @param diskBaseName like sdc
function isSanDiskUSB(){
    local diskBaseName=$1; shift
    local vm=$(blockDeviceName ${diskBaseName})
    [[ $vm =~ ^'SanDisk Extreme' ]]
}

## Return a list of device names that appear to be SanDisk Extreme devices
## 
function enumerateSticks(){
    local result=''
    local stick
    for stick in /sys/block/sd*; do
        local diskBaseName=$(basename $stick)
        if isSanDiskUSB ${diskBaseName}; then
            result="${result} ${diskBaseName}"
        fi
    done
    echo -n ${result};
}

## Validates that the device visible as diskBaseName is indeed
## a 'SanDisk Extreme' make and model.
# @param diskBaseName like sdc
# @deprecated:  when running this function in a shell, and the stick is not valid, it closes the shell.
function validateStick(){
    local diskBaseName=$1; shift
    echo "checking ${diskBaseName}"
    if [ ! -e /sys/block/${diskBaseName} ] ; then
        echo "${diskBaseName} is not a suitable device or not a block device at all, bye..."
        exit 1
    fi
    ## test for SanDisk Extreme
    ## read vendor and model
    if  ! isSanDiskUSB ${diskBaseName} ; then
	echo "device /dev/${diskBaseName} should be a 'SanDisk Extreme' but was a '${vm}'"
	exit 1
    fi
    #echo "found device '$vm' at /dev/${diskBaseName}"
}

## Mount all sticks that report as of th proper type
## @post-condition: all sticks have their writable partition 3 mounted

function mountAllSticks(){
    local counter=0
    for baseDisk in $(enumerateSticks); do
	local locacounter=$((${counter}+1))
	local probemount=/media/${USER}/${baseDisk}3-stickmountprobe
	local part=${baseDisk}3
	mkdir -p ${probemount}
	mount --options ro /dev/${part} ${probemount}
	local labelFile=${probemount}/upper/sebi-label
	if [ -e ${labelFile} ]; then
	    label=$(cat ${probemount}/upper/sebi-label)
	else
	    label=UNKNOWN${counter}
	fi
	## create final mount point
	local finalmount=/media/usb/${label}-writable
	mkdir -p ${finalmount}
	mount --bind --options rw ${probemount} ${finalmount}
	mount --options remount,rw /dev/${part} ${finalmount}
    done
    sync
    echo 'waiting a second for mount activity to settle down'
    sleep 1 # let the machine recover
    for probemount in $(cat /proc/mounts \
		    | grep '\-stickmountprobe' \
		    | awk '{print $2}') ; do
	umount ${probemount}
	rmdir ${probemount}
    done
}


# Enumerate  mounted stick partitions
# @return the space separated list of mounted partitions
function mountedPartitions(){
    local mounted=""
    for d in $(enumerateSticks); do
	for p in $(cat  /proc/mounts \
		       | awk '{print $1}'\
		       | grep -s "/dev/${d}" ) ; do
	    if [ -z "$mounted" ]; then
		mounted="$p"
	    else
		mounted="${mounted} $p"
	    fi
	done
    done
    echo "$mounted"
}


## unmount all stick partitions. Remove all directories under /media/usb/*
## @post all sticks are umounted
function umountAllSticks(){
    local part
    local dev
    for part in $(mountedPartitions) ; do
        umount ${part}
    done
    # cleanup up any mount points left
    for dev in $(find /media/usb/ -mindepth 1 -maxdepth 1 -type d); do
        rm -fr ${dev}
    done
}


##
## make partition 3 on stick
## @param stick/ disk to use
function initPartition3(){
    local stick=$1; shift
    validateStick ${stick}
    ## make sfdisk use defaults for start and end, a.k.a. all remaining space
    echo "," | sfdisk  --quiet --append /dev/${stick} -N3 &> /dev/null
    ## make sure the kernel sees the new partition
    partprobe /dev/${stick}
    ## make a file system in the partition
    mkfs.ext2 -q -F -L writable /dev/${stick}3
    ## make sure the file system actions are flush to the device
    sync /dev/${stick}3
}

##
## Prime a partition sdX3 with label and initial home directories.
## @param disk partition to prime
## @param label to use. 
function primePartition3(){
    local disk=$1; shift
    local label=$1; shift
    ## make the partition  and create file system in partition3
    if isSanDiskUSB ${disk} ; then
        initPartition3 ${disk}
        ## mount the file system
        local rootmp=/media/usb/${label}-writable
        mkdir -p ${rootmp}
        mount /dev/${disk}3 ${rootmp}
        ## create a default directory structure
        mkdir -p ${rootmp}/{upper/etc,work/work}
        ## put the label file in sebi-label and hostname
        echo ${label} | tr 'A-Z' 'a-z' > ${rootmp}/upper/etc/hostname
        echo -n ${label} > ${rootmp}/upper/sebi-label
        ## expand skel for home/<user>
        if [ -e examskel.tgz ]; then
            userhome=${rootmp}/upper/home/exam
            mkdir -p ${userhome}
            tar -C ${userhome} -xf examskel.tgz
            chown -R 1001:1001 ${userhome}
            echo "created home dir for 'exam' on device ${disk}3"
        fi
        if [ -e sebiskel.tgz ]; then
            userhome=${rootmp}/upper/home/sebi
            mkdir -p ${userhome}
            tar -C ${userhome} -xf sebiskel.tgz
            chown -R 1002:1002 ${userhome}
            echo "created home dir for 'sebi' on device ${disk}3"
        fi
        sync /dev/${disk}3
        umount ${rootmp}
    fi
}

## Mount the usb stick as /media/usb/<label>-writable
## as in /media/usb/EXAM350-writable
## @param old mount point 
## @param label
function remount(){
    local omp=$1; shift
    local label=$1; shift
    local nmp=/media/usb/${label}-writable
    mkdir -p ${nmp}
    mount --bind ${omp} ${nmp}
    umount ${omp}
}

##
## Prepare a set of stick with stick class, image and initial label number.
## example prepareSticks EXAM image.iso 350 sdc sdd sde sdf
## @param stick_class EXAM oe SEBI
## @param image the iso file to use
## @param startDiskNr the initial disk number
## @param disk1 [disk2 [...]]
function prepareSticks(){
    echo "received $# params: [$@]"
    local stick_class=$1; shift
    local image=$1; shift
    local startDiskNr=$1; shift
    # ensure no disk is mounted
    umountAllSticks
    while [ $# -gt 0 ]; do
        local disk=$1; shift
        if isSanDiskUSB ${disk}; then 
            local label=${stick_class}${startDiskNr}
            echo "preparing stick ${disk} as ${label}"
            ## run as detached sub process
            (
                # last chance to bail out before writing
                validateStick ${disk}
                dd if=${image} of=/dev/${disk} bs=4M conv=fsync
                echo "#writing base iso to ${disk} completed"
                primePartition3 ${disk} ${label}
            ) &
            startDiskNr=$((${startDiskNr}+1))
        fi
    done
    echo "wait for completion of sub processes"
    wait
    echo "all child processes returned"
}
